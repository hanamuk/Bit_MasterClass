C언어 정리
1. 언어 : 컴파일러

자바- 플렛폼인디펜던트 특징을 위해 나온언어
MFC는 언어가아니고 라이브러리 
DLL도 라이브러리..

포인터의 크기가 다 4byte인데 한가지 예약어가 아닌 char, int, flaot*처럼 나눈이유는
시작주소에서 메모리를 얼마나 읽어야하는지 알게 하기위해서 포인터변수의 앞에 자료형을 적는다.

WIn32 와 같은(win64)것에서 뒤에 숫자는
1. int 사이즈


프로그램과 프로세스 차이
- 프로세스는 cpu time할당.
- 프로세스는 메인메모리 할당.(프로세스에게 할당되는 메모리의 사이즈)
- win32는 한클락의 32bit처리 가능, 한번 프로세스를 처리할떄 2의32승 = 4GB씩만큼 할당가능?, win64에서는 16엑사바이트?만큼..
- win32의 속한 os(xp,nt,2000) 같은거를 만들때 사용된 함수를 모아둔것이 Win32API


WIN32를 캡슐화, 상속, 다형성을 해서 객체지향으로 만든것이 MFC

RAM에서 메모리가 부족할떄 하드디스크의 일부를 땡겨와서 사용하는것이 가상메모리


2일차...
1. #은 전처리기라는 뜻 여기서 처리기는 컴파일러를 뜻한다. 즉 컴파일하기전에 무엇을 해야할떄 #을 사용한다
2. 해더파일에서 이미 포함되어있으면 한번만 포함시켜라는 명령어 
3. #ifdef 는 아래를 예로치면 MY_ARRAY가 있다면 바로아래의 소스코드가 실행되고 만약  #define MY_ARRAY 처럼  MY_ARRAY가 없다면 else의 블록부분의 소스코드가 실행된다. 
	#ifdef 종류는 많이사용된다고한다.
4. 프로그램을 OS가 메모리에 올릴때 OS는 Main함수를 호출해준다 컴파일러가 아니고 OS가 호출해주는것
5. printf에서 % 사이에 #을 쓰면 해당진수에 따른 기호를 넣어서 표시해준다..

6. 메모리에서 제일위는 code영역이고 그다음 Data영역에 전역변수가있고, 그다음 Heap영역에 동적메모리
   제일아래 Stack영역에 지역변수가 할당. 즉 code-> data -> heap -> stacks 

7. 변수에서 헝가리안 표기법을 사용하자.
8. 값앞에 &를하면 주소가 나오고 주소앞에 *하면 값이나온다..


3일차
1. sizeof는 메모리의 크기를 알아오는 친구다.
2. 문자열의 '\0' == 0 이다.
3. scanf는 화이트스페이스(스페이스바, 탭, 엔터) 단위로 잃어오기때문에 공백이 들어가는 문자를
   받을경우에는 gets, puts를 사용한다.
4. 파일 io나 입출력같은것의 흐름? 을 스트림이라고 하는데 파일io에서는 이 스트림을 만들어주고닫아야한다.
5. 어떠한 데이터를 받아서 저장해 ㄱ일괄 관리하는 것. 성능향상이 좋음.

6. 표준, 비표준 입출력함수 여부는 버퍼의 사용여부로 결정된다. 표준이 버퍼사용.
7. 파일의 끝은 EOF char형인데 -1로 정의되어있음. (ctrl + Z)
8.  파일은 사실 TextFile과 binary File(2진형식)로 나누어져있다.
9. 파일 스트림을 만들때 입,출력 따로 만들어야한다.

10 . 함수내에서 카운트할떄 전역변수를 생각하는 경우가 많은데 전역변수는 goto문처럼 사용하지 않는것이 좋다.
     그렇기 떄문에 전역변수를 안사용하는대신에 static으로 함수안에 선언하여 사용하면 static변수는 오래 살기떄문에 
     이것으로 사용하면된다. 즉 static을 지역변수에 사용하면 변수의 사용범위는 지역안인데 살아있는 기간은 프로그램이 종료
     될떄까지 이다.
11. 사용할 함수의 리턴, 매개변수의 타입이 다 똑같아야 함수포인터를 선언할 수 있다.
-------------추가
12. 함수의 이름도 주소이다.


4일차.
1. char에서 300 이 안들어가는 이유는 2의8승 - 1까지의 범위로 들어가는데 그럼 0~ 255까지만 들어갈 수있다.
1-2 : int 는 2의 8*4(인트의 바이트수) -1 이 범위이다.

2. win16에서 char = 1바이트, short = 2b, int = 2b, long = 4b 
   win32에서 char = 1바이트, short = 2b, int = 2b, long = 8b 
	
3. float = 4b, double = 8b
4. 프로그램은 실행가능한 파일이다. 프로세스는 잠자고있는 프로그램(.exe)(하드디스크 같은곳에 있는)을 
   실행(하드디스크에서 RAM에 올려주는것)을 시키면 그 프로그램안의 변수들을 (data,heap,stack)메모리 중하나에 올린다?

5. * 값연산자(단항연산자 일때는 값연산자, 이항이면 산술op 곱셈연산자, 선언부에서 쓰면 포인터 타입선언),
    그냥 값변수에 *a 처럼 쓰면 에러가난다, 이미 값변수에 값연산자를 사용했기 때문에.

6.  & : 주소연산자(이항이면 논리op 비트 연산자, 단항이면 주소연산자. 선언부에서 쓰면 참조(별명)타입 선언(C++사용))

7.  ()가없으면 연산자, 있으면 함수.  

8. 배열의 이름은 주소다. 배열에서(ex b[3]) b[0]에 값을 넣으려면 b*= 100이런식으로 하면 되는데 b[1]에 넣기위해서는
  *b+1 = 100 이렇게 하면 틀리고 *(b+1)로 해야한다. 그래야 주소값이 더해지기 떄문에,, 앞처럼하면 값에 1이 더해진다.

9. int *p[4]; 는 int*를 4개 만들어라 라는 소리라서(포인터의 배열이다 :포인터들을 배열로만든것) sizeof(p) = 16byte이고 
   즉 포인터 들을 모아서 배열을 만들었다. 

//////////////////// 확인해봐야함
10. int (*pa)[4]; 는 배열을가르키는 포인터이다. = 배열을 가르키는 포인터? .. pa++을하면 4칸씩 뛰어넘어간다. 
만약 b[2][4]라는 배열을 pa= b 라고 넣고 p++을 하면 b[0][0]에서 > b[1][0]로 넘어간다.
///////////////////////

11. int (*pa)[4]; 는 pa라는 포인터 1개를 만든거기때문에 4byte이다. int (*pa)[4]는 int형 4개를 한 묶음 으로 보기때문에
    pa++를 하면 해당되는 배열에서 4칸을 한번에 건너뛴다.


12. const 는 위치에 따라 좀 다르다. 
12-1     const 가 맨앞에 있을떄는 *p = a 는 에러가 나오고 , p= &a를 넣는건 괜찮다. 즉 이건 *p를 
           read only로 하는거고 p는 그대로라서 바꿀 수 있는것이다.
12-2     int *const p 처럼 const가 있을떄는 *p =&a 처럼변경은 할수있지만 p= a는  에러다.
12-3    const int *const p는 위의 케이스 둘다 못바꾼다.


5일차
1. 정적(static) : 컴파일타임에 동작이 끝나는것 (실행타임보다 먼저)

2. 동적(dynamic) : 실행타임에 동작이끝나는것 (컴파일타임 뒤)

동적 liked list 사용한 정보저장....


6-----------
1. Win API를 객체 지향으로 바꾼게 MFC 둘다 라이브러리다

2. 오버로딩을 사용할 수 있는 이유는 네임맹글링을 사용함으로 사용가능 하도록 하는 것
  - 근데 네임맹글링 단점이있는데 검색해보자. 그 라이브러리를 팔 때 맹글링하면 다른사람이 가져다 쓸떄 부서져서 사용하지 못한다. 그래서 앞에 extern“C”(c스타일로 만들어라)를 코드에 작성하여 사용한다

3. inline은 #을사용한 매크로 함수를 사용한 것처럼 호출이아니고 바로 실행된다.

- C++ 셤문제 : OOP언어 특징 3개 – 캡슐화, 상속, 다형성

4. 오버라이딩 : 함수의 내부를 재정의 하는 것.
5. 진짜 재정의는 visual 키워드를 사용해서 하는 것. 포인터에서 사용할떄...


7------------

1. 클래스 맴버 변수중에  객체들 사이에서 공유하고싶은 변수(shared member)가 있을 때는 
 클래스 내부에 static변수를 선언하면 된다(ex. 객체가 몇개 생겼는지 확인하는 count변수)

2. static 함수는 static 변수만 사용가능 , 이유는 : static 함수를 사용할때 static 변수가 아니면 아직 생성되지 않았을 수도 있기 때문에.

3. static 함수는 밖에서 인스턴스를 생성하지 않아도 사용가능하다.

	CMyString& CMyString::operator=(const CMyString& rhs)
{
	if(this != &rhs)
	this->SetString(rhs.GetString());
}